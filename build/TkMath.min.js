/* @hrimthurs/tackle 1.21.0 https://github.com/hrimthurs/Tackle @license MIT */
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).TkMath={})}(this,(function(t){"use strict";const n=Math.PI/2,e=Math.PI/4,o=2*Math.PI,r=Math.PI/180;function s(t,n){return t.x*n.x+t.y*n.y}function i(t,n){return t.x*n.y-t.y*n.x}function u(t,n){return{x:t.x-n.x,y:t.y-n.y}}function c(t,n,e=.1){const o=u(n,t);return Math.abs(o.x)<e&&Math.abs(o.y)<e}function f(t,n){const e=u(n,t);return Math.sqrt(e.x**2+e.y**2)}function a(t,n){const e=u(n,t);return Math.abs(e.x)+Math.abs(e.y)}function y(t,n,e){return a(e,t)<a(e,n)}function l(t,n,e,o=1.2){let r=!1;const s=u(n,t),i=s.x**2+s.y**2;if(0!==i){const u=((e.x-t.x)*s.x+(e.y-t.y)*s.y)/i;if(u<0)r=Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2)<=o;else if(u>1)r=Math.sqrt((n.x-e.x)**2+(n.y-e.y)**2)<=o;else{const n=((t.y-e.y)*s.x-(t.x-e.x)*s.y)/i;r=Math.abs(n)*Math.sqrt(i)<=o}}return r}function x(t,n){let e=!1;for(let o=0,r=n.length-1;o<n.length;r=o++){const s=n[o],i=n[r];s.y>t.y!=i.y>t.y&&t.x<(i.x-s.x)*(t.y-s.y)/(i.y-s.y)+s.x&&(e=!e)}return e}function h(t,n,e,o){let r=null;if(t&&n&&e&&o){const s=u(t,n),c=u(o,e),f=i(s,c);if(0!==f){const t=u(o,n);r={Ua:i(t,c)/f,Ub:i(s,t)/f}}}return r}function d(t){return t&&t.Ua>=0&&t.Ua<=1&&t.Ub>=0&&t.Ub<=1}function g(t,n,e){return{x:n.x*t.Ua+e.x*(1-t.Ua),y:n.y*t.Ua+e.y*(1-t.Ua)}}function D(t,n,e,o=(t=>{})){let r=!0;const[s,i]=t,[u,f]=n;return c(f,s,e)||c(u,s,e)?o(!0):c(u,i,e)||c(f,i,e)?o(!1):r=!1,r}function P(t,n){return{first:t[n[0]],last:t[n[n.length-1]]}}var M={HALF_PI:n,QUART_PI:e,DOUBLE_PI:o,angleDegToRad:function(t=0){return Number(t)*r},roundFloat:function(t,n=3){return Number(t.toFixed(n))},dotProduct2D:s,crossProduct2D:i,delta2D:u,midPoint2D:function(t,n){return{x:(t.x+n.x)/2,y:(t.y+n.y)/2}},isEqualCoords2D:c,dist2D:f,distManhattan2D:a,isNearerFirstPt2D:y,areaPolygon2D:function(t,n=!1){const e=t.reduce(((n,e,o)=>{const r=t[(o+1)%t.length];return n+=e.x*r.y,n-=r.x*e.y}),0)??0;return n?e:Math.abs(e)},pointOnLineByLen2D:function(t,n,e){const o=u(n,t),r=e/(f(t,n)||1);return{x:t.x+o.x*r,y:t.y+o.y*r}},projectPointToStraightLine2D:function(t,n,e){const o=u(n,t),r=s(u(e,t),o)/s(o,o);return{x:t.x+o.x*r,y:t.y+o.y*r}},isPointBelongStraightLine2D:function(t,n,e,o=1.2){const r=u(n,t),s=i(r,u(e,t)),c=Math.sqrt(r.x**2+r.y**2);return Math.abs(s/c)<=o/2},isPointBelongLineSegment2D:l,isSomePointBelongLineSegment2D:function(t,n,e,o=1.2){return e.some((e=>l(t,n,e,o)))},isEveryPointBelongLineSegment2D:function(t,n,e,o=1.2){return e.every((e=>l(t,n,e,o)))},isPointInsidePolygon2D:x,isSomePointInsidePolygon2D:function(t,n){return t.some((t=>x(t,n)))},isEveryPointInsidePolygon2D:function(t,n){return t.every((t=>x(t,n)))},crossStraightLines2D:function(t,n,e,o){const r=h(t,n,e,o);if(r)return g(r,t,n)},crossLinesSegments2D:function(t,n,e,o){const r=h(t,n,e,o);if(d(r))return g(r,t,n)},isCrossLinesSegments2D:function(t,n,e,o){return!0===d(h(t,n,e,o))},chainsLinesSegments2D:function(t,n=!1,e=.1){let o=[];return t.forEach(((n,r)=>{o.some((o=>o.some(((s,i)=>D(n,t[s],e,(t=>{o.splice(i+(t?0:1),0,r)}))))))||o.push([r])})),o.length>1&&(o=function(t,n,e){const o=t.filter(((o,r)=>{let s=!1;const i=P(n,o);for(let u=r+1;u<t.length;u++){const r=t[u],c=P(n,r);if(s=D(i.first,c.last,e,(()=>r.push(...o)))||D(i.last,c.first,e,(()=>r.unshift(...o)))||D(i.last,c.last,e,(()=>r.push(...o.reverse())))||D(i.first,c.first,e,(()=>r.unshift(...o.reverse()))),s)break}return!s}));return o}(o,t,e)),o.map((o=>{n&&o.forEach(((n,e)=>{const r=e<o.length-1?o[e+1]:o[0],[s,i]=t[r],[u]=t[n];y(i,s,u)&&(t[r][0]=i,t[r][1]=s)}));const{first:r,last:s}=P(t,o),i=o.length>2&&D(r,s,e);return{inds:o,closed:i}}))}};t.default=M,Object.defineProperty(t,"__esModule",{value:!0})}));
